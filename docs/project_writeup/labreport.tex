\documentclass[11pt]{article}
% Use wide margins, but not quite so wide as fullpage.sty
\marginparwidth 0.5in 
\oddsidemargin 0.25in 
\evensidemargin 0.25in 
\marginparsep 0.25in
\topmargin 0.25in 
\textwidth 6in \textheight 8 in
% That's about enough definitions

\usepackage{setspace}
\usepackage{url}
\usepackage{amsmath}

\begin{document}
\author{Mark Gius\vspace{10pt} \\
        Advisor: Dr. Zo\"e Wood
        }
\title{Senior Project: AutoRPG}
\maketitle

\begin{abstract}
Most video games on the market today are geared towards players with fast reflexes and favor quick action over careful planning. This trend has particularly affected the Console Role Playing Game.  Where in the past the pace of the game afforded time to choose an action and select it, newer games progress at a breakneck pace, leading to less direct player interaction and more scripted actions.

I seek to create a game that only allows user interaction via pre-defined character behavior to encourage planning over quick actions.
\end{abstract}

\doublespacing
\section{Introduction}

\textbf{This needs to be modified, or the abstract does.}

Most video games on the market today are geared towards players with fast reflexes and favor quick action over careful planning. This trend has particularly affected the Console Role Playing Game.  Where in the past the pace of the game afforded time to choose an action and select it, newer games progress at a breakneck pace, leading to less direct player interaction and more scripted actions.  One such game, Final Fantasy XII, allowed the player to provide sets of actions for their characters to perform automatically in battle in addition to manually entered actions. \cite{Gambits} This preserved a significant amount of tactical planning in the game. A well-designed set of actions could often make the difference between victory and defeat.

A game that only allowed battle actions through pre-defined character tactics would force the player to think deeply about their opponents and characters in order to develop a winning strategy. 

\section{Previous Work/Related Work}

There are several other games that feature similar gameplay mechanics.  

\begin{description}
\item[RoboCode \cite{RoboCode}] \hfill \\
      ``Robocode is a programming game, where the goal is to develop a robot battle tank to battle against other tanks in Java or .NET.'' Robocode contains a similar ``AI'' approach to player interaction, but requires the user to create their AI in a supported programming language.  This limits the potential audience to programmers and those willing to learn.  Ideally non-programmers would be able to play the game as well.

\item[Final Fantasy XII \cite{Gambits}] \hfill \\
      Final Fantasy XII is the primarily influence for AutoRPG. Final Fantasy XII allows for the player to override the pre-programmed strategies at any time.  This allows a sufficiently fast player to react to battle events as they occur rather than predicting them ahead of time.  Ideally players would not be rewarded to quick reflexes but for thinking ahead and planning out their strategy in advance.

\end{description}

%What other solutions have been proposed or implemented for this problem? Why are they not good enough? You must prepare the readers to believe that your solution (which you have not yet said anything about) is better than these other attempts. This is also the section where you describe any work that your solution is built on top of. Include references to relevant related work.

\section{Implementation}

A simple prototype game was developed in Python using the PyGame game development framework.  The game supported a simple frontend to visualize the more interesting backend action. The game features a battle system that completely disallows user interaction, instead forcing the user to develop pre-defined strategies ahead of time.

\subsection{Frontend}

The frontend largely serves to display the information for the battle.  It serves a secondary purpose of allowing future development to take the project from proof of concept to full fledged game if future developers so desired.

\subsubsection{Block Based Movement}

In most SNES era RPG games, player characters moved about the overworld in discrete steps as though the world was divided into a grid.  A single press of any direction would cause movement until the player was fully contained in the next block created by the grid.  I wanted to recreate this behavior for the simple overworld screen.

The block based movement algorithm implemented has the following characteristics:
\begin{description}
   \item[Characters must move in discrete blocks] \hfill \\
   Movement must begin and end on specific points on a grid.  Characters cannot stop between these points and cannot change direction except on these specific points. 
   \item[The current direction takes precedence] \hfill \\
   So long as the direction key corresponding to the current direction continues to be held down, the player will continue walking that direction.  The addition of additional direction keys has no effect on the current directions.
   \item[The order that directions are pressed matters] \hfill \\
   If several directions are pressed at the same time, the first one pressed takes precedence.  A player that holds down right, then presses and holds up followed by down, will find their character moving up when right is released.
\end{description}

This behavior is achieved using a bitset and a queue.  

PyGame contains an event system.  A PyGame library call provides the caller with a queue of events that have occurred since the last call to the event system.  Keyboard presses are processed as events to be handled by the game code.  For every keypress, PyGame generates two events: one when the key is depressed, and one when it is released.  Because PyGame does not track the current state of input devices itself, we must keep track of the current state of the keyboard ourselves.  This is where the bitset is used.  Each direction is assigned a value that can be expressed as a power of two. These values can be stored by using bitwise operators.  For example:

\begin{align*}
Left = 00000001 \\ 
Right = 00000100 \\
Left \land Right = 00000101
\end{align*}

When keys are depressed, the appropriate number is bitwise ANDed into the bitset.  On key release the inverse of the appropriate number is bitwise ANDed, removing that bit from the set.  By querying the bitset, the set of depressed keys can be returned.

The bitset is useful for determining which keys are currently depressed, but it does not provide any information about the order in which keys were depressed.  To keep track of the ordering of keypresses, The set of keypresses are also recorded in a queue, to preserve the order of the keypresses.  At each frame update, the character sprite is animated and moved around the screen based on its current movement direction.  

When the character reaches a grid intersection point, a new direction must be chosen.  The current direction is used to determine if that key is still depressed. If so, the character continues moving in the same direction.  If not, the queue of directions is used. Each direction in the queue is compared against the current set of depressed keys.  When a direction is found that is still depressed, the character moves in that direction.  The queue is emptied when the character has stopped and all keys have been released.

The implementation for the block based movement can be found in \texttt{character/character.py} in the \texttt{Character} and \texttt{PlayerCharacter} classes.

\subsection{Battle Backend}

The battle backend serves primarily as a stimuli-response system.  Characters take turns deciding a course of action and performing that action.  All possible actions are predefined as Python Classes.  Actions include a simple Attack or Spells.  Armor can be used to reduce damage from weapons, and elemental attributes can be used to reduce or increase the potential damage.  

Conditions are somewhat more flexible.  In theory, any attribute of a player or enemy can be examined to determine whether an action should be taken.  These can be as simple as choosing the enemy with the least hit points remaining to complicated queries designed to strike the enemy most likely to cause the most damage.

%(a) Overview of Solution. Describe in broad terms your project and solution
%(b) Main Algorithm or Interesting Details. Either describe the main algorithm in your project or if appropriate, Pick some of the key areas of your project that you are particularly proud of (that were either complex or tricky or just the most interesting to you). Describe in detail your solution to these aspects of your overall problem. Think about someone else trying to implement what you just did, what information would be most useful for them?

\section{Results} 
%Describe your results. Please include at least 3-6 screen shots of your results, which highlight the capabilities of your project.

\section{Future Work}

Future endeavors should probably be directed towards modifying existing games, rather than continuing work on a from-scratch game.  Most RPG type games probably feature a very structured set of actions and character interactions.  Adding on a structured stimuli-response system similar to what has been prototyped here would be a relatively simple task.

Once the backend has been put in place, competitions could be formed around the system, such as those often associated with RoboCode.  Player vs Player would be tricky to set up.  Player vs. Computer situations would be much easier to establish and regulate.  Categories such as least moves to win against pregenerated opponents would have people optimizing their strategies well. 

If the prototype implementation were to be improved in some manner, the best way forward would be to make the combat more complex so that more complex strategies could be built around it.  Ideas for expansion would involve multiple characters on the player team, the ability to target multiple combatants with abilities, and strategies that can choose targets based on these additions. More complex equipment loadouts and damage potential could also lead to to more complex strategy possibilities.

%What is the next stage? What didn't you get done that you should have? Now that you're done, what should the next person do to carry on the project? Frequently senior projects are a portion of a larger project, and you have to make sure that your work is understandable by the next person to work on the project.

\section{Appendices}

The source code for this project is available on GitHub, located at \url{https://github.com/mgius/senior_project}, under a BSD license.  Media assets are licensed Creative Commons Attribution NonCommercial.

%(as needed) for proofs, user manuals, etc.

%Please remember that this is a formal report that will remain in the library after you graduate. As such, it should be written with formal language and clear exposition. This report should demonstrate your mastery of the topic you have chosen for your senior project. It should be something you are proud of in the end.

\bibliographystyle{plain}
\bibliography{labreport}

\end{document}
